#include<stdio.h>
#include<string.h>

/*
解説とかを参考に、次のようにすればよいことが分かった。

与えられた正の整数Nに対して、
u = a xor b
v = a  +  b, v <= N
となるような非負整数a,bが存在するような(u,v)の組が何通りあるかを数えたい。

a,bからu,vを計算するために筆算を行うことを考える：
(例)
a = 11010...
b = 10011...
すると、各桁ごとに、aとbのうちその桁が1であるようなものが何個(0,1,2)あるかのみを数えれば、
u,vは計算できることが分かる。

逆に、各桁ごとの1の個数を並べて得られる数列が異なるようなa,bの組に対しては、u,vも異なることが示せる(たぶん)。

したがって、「各桁ごとの1の個数を並べて得られる数列」であって、そこから和vを計算したときに、
vがN以下であるようなものの個数を数えればよい。そのために、この数列の値を上の桁から決めていくことにする。
このとき、決めた値とNが十分に離れていれば、それ以降はN以下という制約を気にしなくてもよい。
実際、下のi桁の和の最大値は、1111...11 + 1111...11 = 1111...110 (1がi個)であるから、
i+1桁目以上の部分において、Nのi+1桁目との差が2以上であれば、制約は気にしなくてもよいということになる。

したがって、どう数えればよいかというと、
a[i][j]を、「上からi桁までを決めたとき、
決めた分の上からi桁目で定まる値と、Nの上からi桁目までの値の差が、min(j,2)以上であるような決め方の総数」とする。

i番目まで決めたとき、差が2以上だったら、i+1番目はどうでもよいので、
a[i][2]　→　0,1,2どれでもa[i+1][2]
a[i][1] →　Nのi+1桁目が0→0ならa[i+1][2] 1ならa[i+1][1] 2ならa[i+1][0]
                        1→0ならa[i+1][2] 1ならa[i+1][2] 2ならa[i+1][1]
a[i][0] →　Nのi+1桁目が0→0ならa[i+1][0] 
                        1→0ならa[i+1][1] 1ならa[i+1][0]

により、Nのi+1桁目が0なら、
a[i+1][2] = a[i][2] + a[i][1]
a[i+1][1] = a[i][1] 
a[i+1][0] = a[i][0] + a[i][1]

Nのi+1桁目が1なら、
a[i+1][2] = a[i][2] + 2*a[i][1]
a[i+1][1] = a[i][1] + a[i][0]
a[i+1][0] = a[i][0] 

a[0][0] = 1, a[0][1] = a[0][2] = 0である。
この漸化式を使って順次計算していけばok。

最終的に、a[64][0] + a[64][1] + a[64][2]が答えである。
*/

/*
なんかたまに弾かれるなって思ったら割り算のmodを間違えていた…
*/

long long sum(long long a, long long b) {
	return (a + b) % 1000000007;
}

int main(void) {
	long long a[65][3];
	long long N,M;
	int i,j,p[64];
	long long ans;
	scanf("%lld", &N);
	M = N;
	for (i = 0; i < 64; i++) {
		p[63 - i] = M % 2;
		M = M / 2;
	}

	a[0][0] = 1; 
	a[0][1] = 0;
	a[0][2] = 0;
	for (i = 1; i < 65; i++) {
		if (p[i-1] == 0) {
			a[i][2] = (3*a[i - 1][2]+ a[i - 1][1]) % 1000000007;
			a[i][1] = a[i - 1][1];
			a[i][0] = (a[i - 1][0]+ a[i - 1][1]) % 1000000007;
		}
		else {
			a[i][2] = (3 * a[i - 1][2] + a[i - 1][1] + a[i - 1][1]) % 1000000007;
			a[i][1] = (a[i - 1][1]+ a[i - 1][0]) % 1000000007;
			a[i][0] = a[i - 1][0];
		}
		/*printf("p[%d] = %d, a[%d][0] = %lld\n	", i, p[i], i, a[i][0]);*/
	}

	ans = 0;
	ans = (a[64][0] + a[64][1] + a[64][2]) % 1000000007;

	printf("%lld\n", ans);



	return 0;
}